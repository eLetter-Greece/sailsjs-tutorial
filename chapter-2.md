# Chapter 2: Toy app

We're now going to be developing a demo applicaiton to show off some of
the basic power of Sails. We want to do this to get a high-level
overview of Sails programming by using generators, and Sails
configuration. The resulting toy app will allow us to interact with it
through URLs, giving us insight into the structure of a Sails app, and
an example of [*REST architecture*](http://rest.elkstein.org/) usin
Sails.

In this chapter we're going to be building a very small verison of the
app we'll be building throughout the rest of this tutorial. We'll be
building an app for #! What type of app? theater, polling, voting in
real time.
 
This example app will consist of users and #! what? 

## Planning the app

As show in chapter 1, we'll start building by generating the skeleton of
a Sails.js using the `sails new` command. 

You'll then update the `package.json` by using the following npm
command: 

```
$ npm install sails-postgresql --save
```

This command installs the Sails.js
[PostgreSQL](http://en.wikipedia.org/wiki/PostgreSQL) (Postgres) 
[adapter](https://github.com/balderdashy/sails-postgresql).

You can see where it added this in the `package.json` file using the
`cat` command.

```
$ cat package.json
.
.
.
    "sails-postgresql": "~0.10.8",
.
.
.
```

Then you need to install the package using the following command:

```
$ npm install .
```

Now we'll want to add version control to our toy app.

```
$ git init
$ git add .
$ git commit -m 'Initial commit'
```

You can then create a new repo in either Github or Bitbucket called
`toyApp` and then pushing it up to the newly created remote repo.

```
$ git remote add origin git@github.com:<username>/toyApp.git
$ git push -u origin --all
```

Now I hope you remember it's never too early to deploy. You can push
this skeleton up to Heroku as shown below:

```
$ heroku create
$ git push heroku master
```

Note that this time the Heroku app address will be different, but the
rest should be very similar to the last deployment.

Now we can begin to create the app itself. When you're building a web
app it's common to build a data model first. A data model is the
representation of the resources needed by our app. In our case the app
will be a #! App type, containing users and #! other stuff?. 

### Simple model for users

There are a number of different choices for a user data model. You can
see that by looking at some of the different user registration forms
available on the web. For the purposes of this initial exercise we'll
go with a very simple data model. Users will have a unique integer
identifier called id, a name, which will be a string, and an email
address, which will be an email data type, which is a special kind of
string defined by Sails.js, will serve as a username. A table showing
this data model is shown below.

Users | Data Type
-----------
id | integer
name | string
email | email

Later in the book we'll cover how we can use the user id to show that a
user has many associated #! associated what?

## The Users resource
Here we're going to implement the users data model we described in the
previous section, along with a simple web interface for that model. The
combination of the data model and the ability to access it via the web
makes up the users resource.

Our Users resource API will be generated by using the command `sails
generate api user`.

```
$ sails generate api user
info: Created a new api!
```

Next we need to configure the app to #!automigrate? automatically
migrate our data. This updates our database with the new `users` data model.

Now we can run the app.

```
$ sails lift --verbose
```

Our toy app will now be available on a local server.

Now if we go to our app's root URL at / (read "slash") we get the same
default Sails page, but by generating the Users api we've also created 
